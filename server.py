"""Entry point for the Bagel MCP server."""

from typing import Any

from mcp.server.fastmcp import FastMCP

from settings import settings
from src.reader import factory

server = FastMCP(
    name="Bagel MCP Server",
    host=settings.LOCAL_HOST,
    port=settings.MCP_LOCAL_PORT,
)


@server.tool(title="Read Robolog Metadata")
def read_metadata(robolog_path: str) -> dict[str, Any]:
    """Return metadata of the robolog as a dictionary.

    The returned dictionary contains basic information about the robolog in addition
    to the entire metadata dictionary.

    - robolog_id: Unique identifier for the robolog, generated by reading the robolog content.
    - path: Path to the robolog file. Please note that it could be a file or a directory.
    - start_seconds: Start time of the robolog in seconds. Please note that this is not always
        the Unix epoch seconds. For example, it can be the time when the robot started recording.
    - end_seconds: End time of the robolog in seconds. Please note that this is not always
        the Unix epoch seconds. For example, it can be the time when the robot stopped recording.
    - duration_seconds: Duration of the robolog in seconds.
    - size_bytes: Size of the robolog in bytes.
    - total_message_count: Total number of messages in the robolog.
    - topics: List of topics in the robolog.
    - type_names: Mapping of topic names to their message type names.
    - message_counts: Mapping of topic names to their message counts.
    - metadata: The entire metadata dictionary of the robolog. The structure of the metadata will
        vary depending of the robolog type, e.g., ROS1, ROS2, PX4 ULog, etc. This dictionary is
        JSON-serializable and can be used to extract additional information about the robolog.

    Args:
        robolog_path (str): Path to the robolog.

    Returns:
        dict[str, Any]: A dictionary containing metadata extracted from the robolog.

    """
    reader = factory.make_topic_frequency_reader(robolog_path)
    return {
        "robolog_id": reader.robolog_id,
        "path": str(reader.path),
        "start_seconds": reader.start_seconds,
        "end_seconds": reader.end_seconds,
        "duration_seconds": reader.duration_seconds,
        "size_bytes": reader.size_bytes,
        "total_message_count": reader.total_message_count,
        "topics": reader.topics,
        "type_names": reader.type_names,
        "message_counts": reader.message_counts,
        "metadata": reader.metadata,
    }


@server.tool(title="Read Logging Messages")
def read_logging_messages(robolog_path: str) -> list[dict[str, Any]]:
    """Return logging messages from the robolog as a list of JSON-serializable dictionaries.

    Each dictionary in the list represents a logging message with the following structure:
    - robolog_id: Unique identifier for the robolog, generated by reading the robolog content.
    - timestamp_seconds: Timestamp of the logging message in seconds. Please note that this is
        not always the Unix epoch seconds. For example, it can be the time when the robot logged
        the message.
    - level: Logging level of the message (e.g., DEBUG, INFO, WARN, ERROR).
    - message: The actual logging message content.

    In addition to the above fields, the dictionary may contain additional fields
    depending on the robolog type, e.g., ROS1, ROS2, PX4 ULog, etc. For example, line number,
    function name, and file name, etc.

    Args:
        robolog_path (str): Path to the robolog.

    Returns:
        list[dict[str, Any]]: A list of dictionaries, each representing a logging message.

    """
    reader = factory.make_topic_message_reader(robolog_path)
    return [msg.to_dict() for msg in reader.logging_messages]


@server.tool(title="Read Topic Messages")
def read_topic_messages(  # noqa: PLR0913
    robolog_path: str,
    topics: list[str] | None = None,
    start_seconds: float | None = None,
    end_seconds: float | None = None,
    ffill: bool = False,
    peek: bool = False,
) -> list[dict[str, Any]]:
    """Return messages for the specified topics and time range as a list of dictionaries.

    Each dictionary in the list represents a message with the following structure:
    - robolog_id: Unique identifier for the robolog, generated by reading the robolog content.
    - timestamp_seconds: Timestamp of the message in seconds. Please note that this is not always
        the Unix epoch seconds. For example, it can be the time when the robot sent or received
        the message.

    The rest of the keys in the dictionary are the topic names, and their values will be the
    corresponding message content. The structure of the message content will vary depending on the
    topic message type. The values are JSON-serializable.

    Args:
        robolog_path (str): Path to the robolog.
        topics (list[str] | None, optional): Topics to read from. If None, all topics are read.
        start_seconds (float | None, optional): When to start reading messages.
        end_seconds (float | None, optional): When to stop reading messages.
        ffill (bool, optional): If True, apply forward fill to the messages topics.
        peek (bool, optional): If True, only return the first record batch.

    Returns:
        list[dict[str, Any]]: A list of dictionaries, each representing a topic message.

    """
    reader = factory.make_topic_message_reader(robolog_path)
    dataset = reader.read(
        topics=topics, start_seconds=start_seconds, end_seconds=end_seconds, ffill=ffill, peek=peek
    )
    return dataset.to_table().to_pylist()


if __name__ == "__main__":
    server.run(transport="sse")
